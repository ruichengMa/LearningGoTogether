# 逃逸分析
逃逸分析是一种确定指针动态范围的方法，可以分析在程序的哪些地方可以访问到指针。它涉及到指针分析和形状分析。 当一个变量(或对象)在子程序中被分
配时，一个指向变量的指针可能逃逸到其它执行线程中，或者去调用子程序。如果使用尾递归优化（通常在函数编程语言中是需要的），对象也可能逃逸到被调
用的子程序中。 如果一个子程序分配一个对象并返回一个该对象的指针，该对象可能在程序中的任何一个地方被访问到——这样指针就成功“逃逸”了。如果指针
存储在全局变量或者其它数据结构中，它们也可能发生逃逸，这种情况是当前程序中的指针逃逸。 逃逸分析需要确定指针所有可以存储的地方，保证指针的生
命周期只在当前进程或线程中。

### 逃逸分析的用处（为了性能）
最大的好处应该是减少gc的压力，不逃逸的对象分配在栈上，当函数返回时就回收了资源，不需要gc标记清除。  
因为逃逸分析完后可以确定哪些变量可以分配在栈上，栈的分配比堆快，性能好。  
同步消除，如果你定义的对象的方法上有同步锁，但在运行时，却只有一个线程在访问，此时逃逸分析后的机器码，会去掉同步锁运行。  
#### 
    go消除了堆和栈的区别
    go在一定程度消除了堆和栈的区别，因为go在编译的时候进行逃逸分析，来决定一个对象放栈上还是放堆上，不逃逸的对象放栈上，可能逃逸的放堆上。
### 开启逃逸分析日志
    编译参数加入 -gcflags '-m -l'
    
    package main
    
    type S struct { 
        M *int
    }
    
    func main() { 
        var i int 
        refStruct(i)
    }
    
    func refStruct(y int) (z S) {
        z.M = &y
        return z 
    }
    
    [root@iZ2ze91d4v3o0r3iahb1p3Z ~]# go build -gcflags '-m -l' main.go
    # command-line-arguments
    ./main.go:13:11: &y escapes to heap
    ./main.go:12:16: moved to heap: y
    
    日志的输出表明，y是逃逸了，因为 z 引用了 y，y 本身是一个 i 的副本。
      


