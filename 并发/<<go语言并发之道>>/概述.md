# 第一章 概述
## 竞争条件
当两个或多个操作必须按正确的顺序执行,而程序并未保证这个顺序,就会发生竞争条件
######
    package main
    
    import "fmt"
    
    func main() {
    	1. var data int
    	2. go func() {
    	3. 	data++
    	4. }()
    	5. if data == 0 {
    	6.	fmt.Printf("the value is %v.\n", data)
    	7. }
    }
    结果:
        第3行在第5行之前执行, 不打印任何东西
        第5行和第6行在第3行之前执行, 打印"the value is 0."
        第5行在第3行之前执行,但第3行在第6行之前执行
        
## 原子性
当某些东西被认为是原子的,或者具有原子性的时候,这意味着它运行的环境中,它是不可分割或不可中断的。  
第一件非常重要的事情是"上下文"这个词, 可能在某个上下文中有些东西是原子性的,而在另一个上下文中却不是.  
换句话说,操作的原子性可以根据当前定义的范围而改变,这种特性对你来说有利有弊!

## 死锁
死锁程序是所有并发进程彼此等待的程序,在这种情况下,如果没有外界的干预,这个程序将永远无法恢复。
#### coffman条件
    相互排斥: 并发进程同时拥有资源的独占权
    等待条件: 并发进程必须同时拥有一个资源,并等待额外资源
    没有抢占: 并发进程拥有的资源只能被该进程释放,即可满足这个条件
    循环等待: 一个并发进程(p1)必须等待一系列其他并发进程(p2),这些并发进程同时也在等待进程(p1).
## 活锁
    活锁是正在主动执行并发操作的程序,但是这些操作无法向前推进程序的状态。
        例子:a 和 b 在走廊相向而走, a 向左移动, b向右移动, a向右移动，b向左移动。无限循环下去就是活锁。
## 饥饿
    饥饿是在任何情况下,并发进程都无法获得执行工作所需的所有资源.
    当我们讨论活锁时,每个goroutine的资源是一个共享锁
    饥饿通常意味着有一个或多个贪婪的并发进程,他们不公平地阻止一个或多个并发进程,以尽可能有效地完成工作,或者阻止全部并发进程。

    